<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-30</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Inventory and Hotbar



//I am using hotbar instead of loadout because
//we might have items down there, which are
//not part of a loadout.

//Mouse is over the inventory
mouse_over = false;

//This code assumes we will always use view[0].
view_width = view_wview[0];
view_height = view_hview[0];

//Size of each cell in inventory and hotbar.
cell_size = 48;

//The padding between cells.
x_padding = 8;
y_padding = 8;

//Cell color.
cell_alpha = 0.95;
cell_color = c_gray;

//Background color.
bg_alpha = 0.55;
bg_color = c_black;

//Text color.
text_color = c_black;
text_alpha = 1.0;

//Whether items can be used or not
can_use_items = true;

//Inventory is disabled
disabled = false;

//Size of the hotbar when we draw it.
hotbar_height = cell_size+(2*y_padding);
hotbar_width = view_width;

//The number of items each loadout can have.
loadout_capacity = 10;

//These slots are used for items that are not
//swapped out when the player switches loadouts,
//such as health potions.
persistent_items_capacity = 3;

//The total number of cells we draw for the hotbar.
hotbar_capacity = loadout_capacity + persistent_items_capacity;

//Inventory capacity (for now).
rows = 4;
cols = 8;
inventory_capacity = rows * cols;

//Inventory width and height.
inventory_width = (cols * cell_size) + ((cols+1) * x_padding);
inventory_height = (rows * cell_size) + ((rows+1) * y_padding);

//The space available for the inventory
//after we draw the hotbar.
var available_space_width = view_width;
var available_space_height = (view_height - hotbar_height);
//The center of the available space.
//This will be the center of the inventory.
inventory_center_x = available_space_width/2;
inventory_center_y = available_space_height/2;

//Initialize the inventory.

//Use obj_empty to represent nothing in that slot.
empty = instance_create(0,0,obj_empty);
for(var i = 0; i &lt; inventory_capacity; i++)
{
    //Set each slot to be empty intially.
    inventory[i] = empty;
    
    //Initialize array of x,y coordinates used for collision
    //detection of each cell.
    inventory_cell_x[i] = 0;
    inventory_cell_y[i] = 0;
    
}

//This is the extra slot we use for holding an item.
inventory[inventory_capacity] = empty;

//Whether we draw the inventory or not.
inventory_open = false;

//This is the extra slot for what the player
//is holding.
cubby = empty;

//Initialize the loadouts.

//We have four passive slots.
first_passive_slot = loadout_capacity - 4;

//How many loadouts we have.
max_loadouts = 4;

//The loadout we are currently using.
current_loadout = 0;

//The loadout used to swap back to with hotswapping (use spacebar).
save_loadout = current_loadout;

saving_loadout = true;

//Initialize Loadouts.
for(var i = 0; i &lt; max_loadouts; i++)
{
    for(var j = 0; j &lt; loadout_capacity; j++)
    {
        //Set each slot of the loadout to be empty initially.
        loadout[i,j] = empty;
        
        if(i == 0)
        {
            //Initialize array of x,y coordinates used for collision
            //detection of each cell.
            loadout_cell_x[j] = 0;
            loadout_cell_y[j] = 0;
        }
    }
}

//Initialize persistent items.
persistent_items[persistent_items_capacity-1] = 0;
for(var i = 0; i &lt; persistent_items_capacity; i++)
{
    //Set each slot to be empty initially.
    persistent_items[i] = empty;
    
    //Initialize array of x,y coordinates used for collision
    //detection of each cell.
    persistent_items_cell_x[i] = 0;
    persistent_items_cell_y[i] = 0;
}

//This enum represents where the cell we clicked on is from.
enum region
{
    INVENTORY,
    LOADOUT,
    PERSIST,
    NONE //Do not use this to mean we clicked outside the inventory.
}

//This is the last item the player used.
//We only make this item visible.
most_recent_item = empty;
most_recent_item_index = -1;

//We need these coordinates later for collision detection.
    //Calculate top left of the Inventory.
    inventory_x1 = view_xview[0] + (inventory_center_x - (inventory_width/2));
    inventory_y1 = view_yview[0] + (inventory_center_y - (inventory_height/2));
    //Calculate bottom right of inventory.
    inventory_x2 = inventory_x1 + inventory_width;
    inventory_y2 = inventory_y1 + inventory_height;
    
//For showing the tooltip
time_over_slot = 0;
cur_slot = -1;
prev_slot = -2;
draw_tooltip = false;
tooltip_item_index = -1;

//Tooltip variables for hotbar
tooltip_region = region.NONE;
hotbar_time_over_slot = 0;
current_hotbar_cell = -1;
draw_hotbar_tooltip = false;

/*
//Create the starting inventory.

totalSlots = 17;
curSlot = 0;
canDraw = false;
canUse = true;
cooldown = 120;
dagger_equip = false;

for(i = 0; i &lt; totalSlots; i++){
    global.slot[i] = "noone";
}

for(i = 0; i &lt; totalSlots; i++){
    coordX[i] = 0;
}

for(i = 0; i &lt; totalSlots; i++){
    coordY[i] = 0;
}

for(i = 0; i &lt;= 2; i++){
    equipped[i] = false;
}

scr_startingvalues();

spr = spr_nothing;
slotTaken = -1;
//*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Uncomment this if using data structures.
///We need to destroy Inventory data structures: stackables and the stacks it contains

/*
//This is untested.
var size = ds_map_size(stackables);
var key = ds_map_find_first(stackables);
for (var i = 0; i &lt; size; i++;)
{
    var value = ds_map_find_value(stackables, key);
    key = ds_map_find_next(stackables, key);
    if(not is_undefined(value))
    {
        ds_stack_destroy(value);
    }
}
ds_map_destroy(stackables);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//canUse = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Toggle inventory visibility.
if(keyboard_check_pressed(global.key_toggle_inventory) &amp;&amp; not disabled)
{
    inventory_open = not inventory_open;
}

/*
///Switch between inventory on and off
if(!canDraw &amp;&amp; keyboard_check_pressed(vk_lshift)){
    canDraw = true;
    return 0;
}
if(canDraw &amp;&amp; keyboard_check_pressed(vk_lshift)){
    canDraw = false;
    spr = spr_nothing;
    return 0;
}
//*/


//Check if the dagger is equipped
//Golden egg, can implement later
/*
if(global.slot[15] == "dagger2"){
    instance_create(obj_char.x, obj_char.y, obj_dagger);
}

if(global.slot[15] != "dagger2"){
    with(obj_dagger) instance_destroy();
}
*/



/*
if(global.slot[15] == "dagger2" &amp;&amp; !equipped[0]){
    instance_create(obj_char.x, obj_char.y, obj_dagger);
    equipped[0] = true;
}
if(global.slot[15] != "dagger2" &amp;&amp; equipped[0]){
    with(obj_dagger) instance_destroy();
    equipped[0] = false;
}

if(global.slot[15] == "bow2" &amp;&amp; !equipped[1]){
    instance_create(obj_char.x, obj_char.y, obj_bow);
    equipped[1] = true;
}
if(global.slot[15] != "bow2" &amp;&amp; equipped[1]){
    with(obj_bow) instance_destroy();
    equipped[1] = false;
}
//*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cycle between loadouts.
if(keyboard_check_pressed(global.key_loadout_cycle_left))
{
    if(saving_loadout)
    {
        save_loadout = current_loadout;
        saving_loadout = false;
    }
    current_loadout--;
    if(current_loadout &lt; 0)
    {
        current_loadout = max_loadouts - 1;
    }
    show_debug_message("current_loadout: " + string(current_loadout));
}
else if(keyboard_check_pressed(global.key_loadout_cycle_right))
{
    if(saving_loadout)
    {
        save_loadout = current_loadout;
        saving_loadout = false;
    }
    current_loadout++;
    if(current_loadout &gt;= max_loadouts)
    {
        current_loadout = 0;
    }
    show_debug_message("current_loadout: " + string(current_loadout));
}
if(keyboard_check_pressed(global.key_loadout_toggle))
{
    show_debug_message("current_loadout: " + string(current_loadout) + " save_loadout: " + string(save_loadout));

    var temp = current_loadout;
    current_loadout = save_loadout;
    save_loadout = temp;
    
    saving_loadout = true;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Toggle tooltip

if(inventory_open &amp;&amp;
    point_in_rectangle(mouse_x, mouse_y, inventory_x1, inventory_y1, inventory_x2, inventory_y2))
{
    tooltip_region = region.INVENTORY;
    //show_debug_message("here " + string(draw_tooltip));
    for(var i = 0; i&lt;inventory_capacity; i++)
    {
        var x1 = inventory_cell_x[i];
        var y1 = inventory_cell_y[i];
        var x2 = x1 + cell_size;
        var y2 = y1 + cell_size;
        if(point_in_rectangle(mouse_x, mouse_y, x1, y1, x2, y2) )
        {
            cur_slot = i;
        }
        if(cur_slot == prev_slot)
        {
            time_over_slot++;
        }
        else
        {   
            prev_slot = cur_slot;
            time_over_slot = 0;
            draw_tooltip = false;
        }
    }
    if(time_over_slot &gt;= 1500)
    {
        //TODO: show tooltip
        draw_tooltip = true;
        tooltip_item_index = cur_slot;
        //show_debug_message("draw_tooltip: " + string(draw_tooltip));
    }
}
else
{
    time_over_slot = 0;
    draw_tooltip = false;
}
if(inventory_open)
{
    var hovering_over_cell = false;
    if(point_in_rectangle(mouse_x, mouse_y, hotbar_x1, hotbar_y1, hotbar_x2, hotbar_y2))
    {
        for(var i = 0; i &lt; loadout_capacity; i++)
        {
            var x1 = loadout_cell_x[i];
            var y1 = loadout_cell_y[i];
            var x2 = x1 + cell_size;
            var y2 = y1 + cell_size;
            if(point_in_rectangle(mouse_x, mouse_y, x1, y1, x2, y2))
            {
                hovering_over_cell = true;
                if(tooltip_region == region.LOADOUT and i == current_hotbar_cell)
                {
                    hotbar_time_over_slot++;
                }
                else
                {
                    if(loadout[current_loadout, i] != empty)
                    {
                        current_hotbar_cell = i;
                        tooltip_region = region.LOADOUT;
                    }
                    hotbar_time_over_slot = 0;
                }
            }
        }
        for(var i = 0; i &lt; persistent_items_capacity; i++)
        {
            var x1 = persistent_items_cell_x[i];
            var y1 = persistent_items_cell_y[i];
            var x2 = x1 + cell_size;
            var y2 = y1 + cell_size;

            if(point_in_rectangle(mouse_x, mouse_y, x1, y1, x2, y2))
            {
                hovering_over_cell = true;
                if(tooltip_region == region.PERSIST and i == current_hotbar_cell)
                {
                    hotbar_time_over_slot++;
                }
                else
                {
                    if(persistent_items[i] != empty)
                    {
                        current_hotbar_cell = i;
                        tooltip_region = region.PERSIST;
                        hotbar_time_over_slot = 0;
                    }
                }
            }
        }
    }
    if(hovering_over_cell)
    {
        if(hotbar_time_over_slot &gt;= room_speed/2)
        {
            draw_hotbar_tooltip = true;
        }
    }
    else
    {
        if(tooltip_region != region.INVENTORY) tooltip_region = region.NONE;
        current_hotbar_cell = -1;
        draw_hotbar_tooltip = false;
    }
}
//sdb(string(hotbar_time_over_slot) + " " + string(time_over_slot));
//sdb("region: " + string(tooltip_region));
//sdb("current hotbar cell " + string(current_hotbar_cell));
//if(not(tooltip_region == region.PERSIST or tooltip_region == region.LOADOUT or tooltip_region == region.INVENTORY))
//{
//    tooltip_region = region.NONE;
//}
//sdb("region: " + string(tooltip_region));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Only Draw if can_use_items == true
if(not can_use_items) exit;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Save alpha and color
save_alpha = draw_get_alpha();
save_color = draw_get_color();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw hotbar and cooldowns

//Top left coordinates of hotbar:
var x1 = view_xview[0];
var y1 = view_yview[0] + (view_height - hotbar_height);
//Bottom right coordinates of hotbar:
var x2 = view_xview[0] + view_width;
var y2 = view_yview[0] + view_height;

//We need to save these coordinates for collision detection.
hotbar_x1 = x1;
hotbar_y1 = y1;
hotbar_x2 = x2;
hotbar_y2 = y2;

//Draw hotbar background.
draw_set_alpha(bg_alpha);
draw_set_color(bg_color);
draw_rectangle(x1,y1,x2,y2,false);

//Prepare to draw hotbar cells

//Update starting position of cells.
x1 += x_padding/2;
y1 += y_padding;
x2 = x1 + cell_size;
y2 = y1 + cell_size;

//Draw hotbar cells.

//Draw the Loadout cells.
for(var i = 0; i &lt; loadout_capacity; i++)
{
    //Set cell color.
    draw_set_alpha(cell_alpha);
    draw_set_color(cell_color);
   
    //Draw cell.
    draw_rectangle(x1,y1,x2,y2,false);
    
    //Save it's collision information.
    loadout_cell_x[i] = x1;
    loadout_cell_y[i] = y1;
    
    var item = loadout[current_loadout,i];
    if(item != empty)
    {
        //If that item has a sprite,
        if(item.sprite_index != -1)
        {
            //Draw the item's sprite.
            scr_inventory_draw_sprite(item,x1,y1);
            
        }
        //Draw cooldown.
        scr_inventory_draw_cooldown(item,x1,y1,x2,y2);
    }
    //Go to next cell.
    x1 += cell_size + x_padding;
    x2 += cell_size + x_padding;
    
    //Draw the passive slots shifted a little from
    //the active items.
    if(i == (first_passive_slot-1))
    {
        x1 += cell_size + x_padding;
        x2 += cell_size + x_padding;
    }
}

//Shift persistent slots by a little to show they 
//are different from loadout slots.
x1 += 3 * (cell_size + x_padding);
x2 += 3 * (cell_size + x_padding);
for(var i = 0; i &lt; persistent_items_capacity; i++)
{
    //Set cell color.
    draw_set_alpha(cell_alpha);
    draw_set_color(cell_color);
   
    //Draw cell.
    draw_rectangle(x1,y1,x2,y2,false);
    
    //Save it's collision information.
    persistent_items_cell_x[i] = x1;
    persistent_items_cell_y[i] = y1;
    
    var item = persistent_items[i];
    
    if(item != empty)
    {
        //If that item has a sprite,
        if(item.sprite_index != -1)
        {
            scr_inventory_draw_sprite(item,x1,y1);
        }
        //Draw cooldown.
        scr_inventory_draw_cooldown(item,x1,y1,x2,y2);
    }
    
    //Go to next cell.
    x1 += cell_size + x_padding;
    x2 += cell_size + x_padding;
}
//Set alpha back to normal so everything else draws properly.
draw_set_alpha(1.0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Inventory

if(inventory_open &amp;&amp; not disabled)
{
    //We need these coordinates later for collision detection.
    //Calculate top left of the Inventory.
    inventory_x1 = view_xview[0] + (inventory_center_x - (inventory_width/2));
    inventory_y1 = view_yview[0] + (inventory_center_y - (inventory_height/2));
    //Calculate bottom right of inventory.
    inventory_x2 = inventory_x1 + inventory_width;
    inventory_y2 = inventory_y1 + inventory_height;
   
    var x1 = inventory_x1;
    var y1 = inventory_y1;
    var x2 = inventory_x2;
    var y2 = inventory_y2;
    
    //Draw the inventory background.
    draw_set_alpha(bg_alpha);
    draw_set_color(bg_color);
    draw_rectangle(x1,y1,x2,y2,false);
    
    //Set x1,y1,x2,y2 to the first cell.
    x1 += x_padding;
    y1 += y_padding
    x2 = x1 + cell_size;
    y2 = y1 + cell_size;
    
    //Save the starting x values so we can
    //remember where the first columns are drawn.
    var original_x1 = x1;
    var original_x2 = x2;
    
    //Draw inventory cells.
    for(var i = 0; i &lt; rows; i++)
    {
        for(var j = 0; j &lt; cols; j++)
        {
            //Set inventory cell color.
            draw_set_alpha(cell_alpha);
            draw_set_color(cell_color);
            
            //Draw cell.
            draw_rectangle(x1,y1,x2,y2,false);
            
            //Current slot.
            var slot = i * cols + j;
            //Current item.
            var item = inventory[slot];
            
            //Save top left x,y of current slot for
            //collision detection later.
            inventory_cell_x[slot] = x1;
            inventory_cell_y[slot] = y1;
                        
            //Draw sprite at cell
            //if the current slot has an item,
            if(item != empty)
            {
                //If that item has a sprite,
                if(item.sprite_index != -1)
                {
                    //If we're not dragging this item,
                    //if(slot != dragging_item_index)
                    {
                        scr_inventory_draw_sprite(item,x1,y1);
                    }
                }
            }
            
            //Move to next cell in the current row.    
            x1 += cell_size + x_padding;
            x2 += cell_size + x_padding;
        }
        //Go to next row.
        y1 += cell_size + y_padding;
        y2 += cell_size + y_padding;
        //Move back to first column.
        x1 = original_x1;
        x2 = original_x2;
    }
    
    
}

//Draw cubby


//else
//{//We're dragging this item, so draw it at the mouse.
//    scr_inventory_draw_sprite(item, mouse_x, mouse_y);                     
//}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Interact with items in inventory and hotbar.

//No longer allowing the player to move items around in the hotbar
//while the inventory is closed because otherwise, if they try to equip
//an item into loadout slot 0, which is activated with a left click,
//that item will instantly activate.
    
if(inventory_open)
{

    var mouse_press = "none";
    
    if(mouse_check_button_pressed(mb_left))
    {
        mouse_press = "left";
    }
    else if(mouse_check_button_pressed(mb_right))
    {
        mouse_press = "right";
    }
    
    if(mouse_press == "left" || mouse_press == "right")
    {
        //Do not use NONE to mean we clicked outside the inventory.
        var clicked_on = region.NONE;
        var item = empty;
        var item_index = -1;
        
        //These variables are used to tell if we clicked outside the inventory or hotbar.
        //They are used to determine if we will drop items outside back to the gamescreen.
        var clicked_on_hotbar = false;
        var clicked_on_inventory = false;
        
        //Check Loadout.
        //If we clicked on hotbar.
        if(point_in_rectangle(mouse_x,mouse_y,hotbar_x1,hotbar_y1,hotbar_x2,hotbar_y2))
        {
            clicked_on_hotbar = true;
            show_debug_message("Clicked in hotbar");
            
            //Check if we clicked on any cell in the loadout.
            for(var i = 0; i &lt; loadout_capacity; i++)
            {
                var x1 = loadout_cell_x[i];
                var y1 = loadout_cell_y[i];
                var x2 = x1 + cell_size;
                var y2 = y1 + cell_size;
                
                if(point_in_rectangle(mouse_x,mouse_y,x1,y1,x2,y2))
                {
                    clicked_on = region.LOADOUT;
                    item = loadout[current_loadout, i];
                    item_index = i;
                }
            }
            
            //Check if we clicked on any of the persistent cells.
            for(var i = 0; i &lt; persistent_items_capacity; i++)
            {
                var x1 = persistent_items_cell_x[i];
                var y1 = persistent_items_cell_y[i];
                var x2 = x1 + cell_size;
                var y2 = y1 + cell_size;
                
                if(point_in_rectangle(mouse_x,mouse_y,x1,y1,x2,y2))
                {
                    clicked_on = region.PERSIST;
                    item = persistent_items[i];
                    item_index = i;
                }
            }
        }
        
        //Check Inventory collision, only if inventory is open.
        //if(inventory_open)
        { 
            if(point_in_rectangle(mouse_x,mouse_y,inventory_x1,inventory_y1,inventory_x2,inventory_y2))
            {
                clicked_on_inventory = true;
                show_debug_message("Clicked in inventory.");
                
                for(var i = 0; i &lt; inventory_capacity; i++)
                {
                    var x1 = inventory_cell_x[i];
                    var y1 = inventory_cell_y[i];
                    var x2 = x1 + cell_size;
                    var y2 = y1 + cell_size;
                    
                    if(point_in_rectangle(mouse_x,mouse_y,x1,y1,x2,y2))
                    {
                        clicked_on = region.INVENTORY;
                        item = inventory[i];
                        item_index = i;
                    }
                }
            }
        }
        
        var area = "";
        switch(clicked_on)
        {
            case region.LOADOUT: area = "loadout"; break;
            case region.PERSIST: area = "persistent"; break;
            case region.INVENTORY: area = "inventory"; break;
        }
        
        if(clicked_on != region.NONE)
        {
            show_debug_message("Clicked on " + string(area) + " at index " + string(item_index));
        }
        
        //If we clicked on a slot.
        if(clicked_on != region.NONE)
        {
            //Left Click
            
            //We are either dropping an item into a slot,
            //or we are picking an item up.
            if(mouse_press == "left")
            {
                //If the cubby is empty, we're picking up an item.
                if(cubby == empty)
                {

                    //swap(cubby,item)
                    cubby = item;
                    cubby.equipped = false;
                    switch(clicked_on)
                    {
                        case region.LOADOUT:
                            with(cubby)
                            {
                                script_execute(deactivation_script);
                            }
                            loadout[current_loadout, item_index] = empty;
                            break;
                        case region.PERSIST:
                            with(cubby)
                            {
                                script_execute(deactivation_script);
                            }
                            persistent_items[item_index] = empty;
                            break;
                        case region.INVENTORY:
                            inventory[item_index] = empty;
                            break;
                    }
                }
                else //We're already holding an item in the cubby.
                {//So we're going to drop it into a slot.
                     
                    //If the slot is empty. 
                    if(item == empty)
                    {
                        //We just drop the cubby in the slot
                        switch(clicked_on)
                        {
                            case region.LOADOUT:
                                if((item_index &lt; first_passive_slot and cubby.passive == false) or
                                   (item_index &gt;= first_passive_slot and cubby.passive == true))
                                {
                                    with(cubby)
                                    {
                                        script_execute(activation_script);
                                    }
                                    loadout[current_loadout, item_index] = cubby;
                                    cubby = empty;
                                }
                                break;
                            case region.PERSIST:
                                with(cubby)
                                {
                                    script_execute(activation_script);
                                }
                                persistent_items[item_index] = cubby;
                                cubby = empty;
                                break;
                            case region.INVENTORY:
                                cubby.equipped = false;
                                inventory[item_index] = cubby;
                                cubby = empty;
                                break;
                        }
                    }
                    else
                    {
                        //We're holding an item in the cubby, and the slot where
                        //we're dropping it has an item.
                        //So we either merge the stacks (if they are the same item),
                        //or we swap the item and the cubby (if they are different items).
                        
                        var swapping = true;
                        if(item.stackable and (item.object_index == cubby.object_index))
                        {
                            swapping = false;
                        }
                        
                        switch(clicked_on)
                        {
                            case region.LOADOUT:
                                if((item_index &lt; first_passive_slot and cubby.passive == false) or
                                   (item_index &gt;= first_passive_slot and cubby.passive == true))
                                {
                                    if(swapping)
                                    {
                                        with(cubby)
                                        {
                                            script_execute(activation_script);
                                        }
                                        with(item)
                                        {
                                            script_execute(deactivation_script);
                                        }
                                        var temp = cubby;
                                        cubby = item;
                                        loadout[current_loadout,item_index] = temp;
                                    }
                                    else
                                    {
                                        item.stack_size += cubby.stack_size;
                                        with(cubby) instance_destroy();
                                        cubby = empty;
                                    }
                                }
                                break;
                            case region.PERSIST:
                                if(swapping)
                                {
                                    with(cubby)
                                    {
                                        script_execute(activation_script);
                                    }
                                    with(item)
                                    {
                                        script_execute(deactivation_script);
                                    }
                                    var temp = cubby;
                                    cubby = item;
                                    persistent_items[item_index] = temp;
                                }
                                else
                                {
                                    item.stack_size += cubby.stack_size;
                                    with(cubby) instance_destroy();
                                    cubby = empty;
                                }
                                break;
                            case region.INVENTORY:
                                if(swapping)
                                {
                                    var temp = cubby;
                                    cubby = item;
                                    inventory[item_index] = temp;
                                    inventory[item_index].equipped = false;
                                }
                                else
                                {
                                    item.stack_size += cubby.stack_size;
                                    with(cubby) instance_destroy();
                                    cubby = empty;
                                }
                                break;
                        }
                    }
                }
            }
            else
            {//We right clicked.
                //We pick up from a stack, but only if the item is stackable.
                if(item.stackable)
                {
                    //If we're not holding anything.
                    if(cubby == empty)
                    {
                        //If the stack size &gt; 1, we break the stack,
                        //so we need a new instance of the item to be in the cubby.
                        if(item.stack_size &gt; 1)
                        {
                            cubby = instance_create(0,0,item.object_index);
                            cubby.visible = false;
                            cubby.on_ground = false;
                            item.stack_size--;
                        }
                        else
                        {//If the stack size is 1, we're picking up the item.
                            cubby = item;
                            switch(clicked_on)
                            {
                                case region.LOADOUT:
                                    loadout[current_loadout,item_index] = empty;
                                    break;
                                case region.PERSIST:
                                    persistent_items[item_index] = empty;
                                    break;
                                case region.INVENTORY:
                                    inventory[item_index] = empty;
                                    break;
                            }
                        }
                    }
                    else
                    {//We're already holding an item, and we right clicked on a stackable item.
                        //We need to check that we're holding the same item.
                        if(cubby.stackable and (cubby.object_index == item.object_index))
                        {
                            cubby.stack_size++;
                            item.stack_size--;
                            if(item.stack_size &lt; 1)
                            {
                                with(item) instance_destroy();
                                switch(clicked_on)
                                {
                                    case region.LOADOUT:
                                        loadout[current_loadout,item_index] = empty;
                                        break;
                                    case region.PERSIST:
                                        persistent_items[item_index] = empty;
                                        break;
                                    case region.INVENTORY:
                                        inventory[item_index] = empty;
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        //Check if we clicked outside.
        if(not(clicked_on_inventory or clicked_on_hotbar))
        {
            with(cubby)
            {
                script_execute(deactivation_script);
            }
            cubby.persistent = false;
            cubby.equipped = false;
            cubby.on_ground = true;
            cubby.visible = true;
            cubby.x = mouse_x-16
            cubby.y = mouse_y-16
            cubby = empty;
        }
    }
    
    //Draw cubby.
    if(cubby != empty and cubby.sprite_index != -1)
    {
        scr_inventory_draw_sprite(cubby,mouse_x-(cell_size/2),mouse_y-(cell_size/2));
    }

}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Equip everything in hotbar

//If you want to remove this code,
//you will need to update the code where
//the player can swap items in the inventory.
//Be careful not to set empty.equipped to true
//because it may have bad effects with drawing
//when activating items.
for(var i = 0; i &lt; loadout_capacity; i++)
{
    var item = loadout[current_loadout,i];
    if(item != empty)
    {
        item.equipped = true;
    }
}
for(var i = 0; i &lt; persistent_items_capacity; i++)
{
    var item = persistent_items[i];
    if(item != empty)
    {
        item.equipped = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw tooltip
if(inventory_open)
{
    if(tooltip_item_index &gt;= 0)
    {
        //show_debug_message("tooltip_item_index: " + string(tooltip_item_index));
        if(draw_tooltip &amp;&amp; inventory[tooltip_item_index] != empty)
        {
            draw_set_font(font_inventory);
            draw_set_alpha(1);
            draw_set_color(c_maroon);
            draw_rectangle(mouse_x - 3, mouse_y - 3, mouse_x + 203, mouse_y + 153, false);
            draw_rectangle_colour(mouse_x, mouse_y, mouse_x + 200, mouse_y + 150,
                c_white, c_white, c_white, c_white, false);
            draw_rectangle(mouse_x - 1, mouse_y + 30, mouse_x + 201, mouse_y + 33, false);
            item_name = inventory[tooltip_item_index].name;
            item_descrip = inventory[tooltip_item_index].description;
            tooltip_text = item_name + "##" + item_descrip;
            draw_set_color(c_black);
            draw_set_halign(fa_left);
            draw_text_ext(mouse_x+10, mouse_y+10, tooltip_text, 15, 160);
        }
    }
    if(current_hotbar_cell &gt; -1 and draw_hotbar_tooltip == true)
    {
        var item = empty;
        if(tooltip_region == region.LOADOUT)
        {
            //sdb("tooltip loadout");
            item = loadout[current_loadout, current_hotbar_cell];

            if(item != empty)
            {
                var tooltip_text = "";
                draw_set_font(font_inventory);
                draw_set_alpha(1);
                draw_set_color(c_maroon);
                draw_rectangle(mouse_x - 3, mouse_y - 153, mouse_x + 203, mouse_y, false);
                draw_rectangle_colour(mouse_x, mouse_y - 150, mouse_x + 200, mouse_y-3,
                    c_white, c_white, c_white, c_white, false);
                draw_rectangle(mouse_x - 1, mouse_y - 123, mouse_x + 201, mouse_y - 120, false);
                tooltip_text = item.name + "##" + item.description;
                draw_set_color(c_black);
                draw_set_halign(fa_left);
                draw_text_ext(mouse_x+10, mouse_y-143, tooltip_text, 15, 160);
            }
        }
        else if(tooltip_region == region.PERSIST)
        {
            //sdb("tooltip persist");
            item = persistent_items[current_hotbar_cell];

            if(item != empty)
            {
                var tooltip_text = "";
                draw_set_font(font_inventory);
                draw_set_alpha(1);
                draw_set_color(c_maroon);
                draw_rectangle(mouse_x - 203, mouse_y - 153, mouse_x + 3, mouse_y, false);
                draw_rectangle_colour(mouse_x-200, mouse_y - 150, mouse_x, mouse_y-3,
                    c_white, c_white, c_white, c_white, false);
                draw_rectangle(mouse_x - 201, mouse_y - 123, mouse_x + 1, mouse_y - 120, false);
                tooltip_text = item.name + "##" + item.description;
                draw_set_color(c_black);
                draw_set_halign(fa_left);
                draw_text_ext(mouse_x-190, mouse_y-143, tooltip_text, 15, 160);
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Restore alpha and color
draw_set_alpha(save_alpha);
draw_set_color(save_color);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="49">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drink potion

/*
if(canUse == true)
{
    alarm[0] = cooldown;
    
    if(global.item[1] &gt; 0 &amp;&amp; global.slot[15] == "potion")
    {
        obj_char.hp+=5;
        global.item[1]--;   
    }

    canUse = false;   
}
//*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
