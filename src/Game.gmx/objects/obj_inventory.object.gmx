<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_nothing</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-30</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Inventory and Hotbar

//I am using hotbar instead of loadout because
//we might have items down there, which are
//not part of a loadout.

//This code assumes we will always use view[0].
view_width = view_wview[0];
view_height = view_hview[0];

//Size of each cell in inventory and hotbar.
cell_size = 48;

//The padding between cells.
x_padding = 8;
y_padding = 8;

//Cell color.
cell_alpha = 0.95;
cell_color = c_gray;

//Background color.
bg_alpha = 0.55;
bg_color = c_black;

//Text color.
text_color = c_black;
text_alpha = 1.0;

//Size of the hotbar when we draw it.
hotbar_height = cell_size+(2*y_padding);
hotbar_width = view_width;

//The number of items each loadout can have.
loadout_capacity = 10;

//These slots are used for items that are not
//swapped out when the player switches loadouts,
//such as health potions.
persistent_item_capacity = 3;

//The total number of cells we draw for the hotbar.
hotbar_capacity = loadout_capacity + persistent_item_capacity;

//Inventory capacity (for now).
rows = 4;
cols = 8;
inventory_capacity = rows * cols;

//Inventory width and height.
inventory_width = (cols * cell_size) + ((cols+1) * x_padding);
inventory_height = (rows * cell_size) + ((rows+1) * y_padding);

//The space available for the inventory
//after we draw the hotbar.
var available_space_width = view_width;
var available_space_height = (view_height - hotbar_height);
//The center of the available space.
//This will be the center of the inventory.
inventory_center_x = available_space_width/2;
inventory_center_y = available_space_height/2;

//Initialize the inventory.

//We use the inventory's id to represent
//that we have no items in that slot
//because it is a unique value guaranteed
//not to be taken by any other instance.
empty = id;
for(var i = 0; i &lt; inventory_capacity; i++)
{
    inventory[i] = empty;
}

//This is the extra slot in the inventory 
//we use for when we split an item from a stack.
inventory[inventory_capacity] = empty;

//Whether we draw the inventory or not.
inventory_visible = false;

//This hashmap is used to store object names
//of stackable items.
//stackables = ds_map_create();

//This is the item we have selected and are dragging.
dragging_item = empty;

//The index of that item in the inventory.
dragging_item_index = -1;

//Initialize array of x,y coordinates used for collision
//detection of each cell.
for(var i = 0; i &lt; inventory_capacity; i++)
{
    inventory_cell_x[i] = 0;
    inventory_cell_y[i] = 0;
}

//TODO: add array for hotbar as well.

/*
//Create the starting inventory.

totalSlots = 17;
curSlot = 0;
canDraw = false;
canUse = true;
cooldown = 120;
dagger_equip = false;

for(i = 0; i &lt; totalSlots; i++){
    global.slot[i] = "noone";
}

for(i = 0; i &lt; totalSlots; i++){
    coordX[i] = 0;
}

for(i = 0; i &lt; totalSlots; i++){
    coordY[i] = 0;
}

for(i = 0; i &lt;= 2; i++){
    equipped[i] = false;
}

scr_startingvalues();

spr = spr_nothing;
slotTaken = -1;
//*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Uncomment this if using data structures.
///We need to destroy Inventory data structures: stackables and the stacks it contains

/*
//This is untested.
var size = ds_map_size(stackables);
var key = ds_map_find_first(stackables);
for (var i = 0; i &lt; size; i++;)
{
    var value = ds_map_find_value(stackables, key);
    key = ds_map_find_next(stackables, key);
    if(not is_undefined(value))
    {
        ds_stack_destroy(value);
    }
}
ds_map_destroy(stackables);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//canUse = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Currently only toggles inventory visibility.
if(keyboard_check_pressed(global.key_toggle_inventory))
{
    inventory_visible = not inventory_visible;
}

/*
///Switch between inventory on and off
if(!canDraw &amp;&amp; keyboard_check_pressed(vk_lshift)){
    canDraw = true;
    return 0;
}
if(canDraw &amp;&amp; keyboard_check_pressed(vk_lshift)){
    canDraw = false;
    spr = spr_nothing;
    return 0;
}
//*/


//Check if the dagger is equipped
//Golden egg, can implement later
/*
if(global.slot[15] == "dagger2"){
    instance_create(obj_char.x, obj_char.y, obj_dagger);
}

if(global.slot[15] != "dagger2"){
    with(obj_dagger) instance_destroy();
}
*/



/*
if(global.slot[15] == "dagger2" &amp;&amp; !equipped[0]){
    instance_create(obj_char.x, obj_char.y, obj_dagger);
    equipped[0] = true;
}
if(global.slot[15] != "dagger2" &amp;&amp; equipped[0]){
    with(obj_dagger) instance_destroy();
    equipped[0] = false;
}

if(global.slot[15] == "bow2" &amp;&amp; !equipped[1]){
    instance_create(obj_char.x, obj_char.y, obj_bow);
    equipped[1] = true;
}
if(global.slot[15] != "bow2" &amp;&amp; equipped[1]){
    with(obj_bow) instance_destroy();
    equipped[1] = false;
}
//*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw hotbar

//Top left coordinates of hotbar:
var x1 = view_xview[0];
var y1 = view_yview[0] + (view_height - hotbar_height);
//Bottom right coordinates of hotbar:
var x2 = view_xview[0] + view_width;
var y2 = view_yview[0] + view_height;

//Draw hotbar background.
draw_set_alpha(bg_alpha);
draw_set_color(bg_color);
draw_rectangle(x1,y1,x2,y2,false);

//Prepare to draw hotbar cells

//Update starting position of cells.
x1 += x_padding/2;
y1 += y_padding;
x2 = x1 + cell_size;
y2 = y1 + cell_size;

//Set cell color.
draw_set_alpha(cell_alpha);
draw_set_color(cell_color);

//Draw hotbar cells.

//Currently loadout capacity is 10 and
//persistent_item_capacity is 3.
//hotbar capacity = loadout_capacity + persistent_item_capacity.
for(var i = 0; i &lt; hotbar_capacity; i++)
{
    //Draw cell.
    draw_rectangle(x1,y1,x2,y2,false);
    
    //Go to next cell.
    x1 += cell_size + x_padding;
    x2 += cell_size + x_padding;
}
//Set alpha back to normal so everything else draws properly.
draw_set_alpha(1.0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Inventory

if(inventory_visible)
{
    //We need these coordinates later for collision detection.
    //Calculate top left of the Inventory.
    var inventory_x1 = view_xview[0] + (inventory_center_x - (inventory_width/2));
    var inventory_y1 = view_yview[0] + (inventory_center_y - (inventory_height/2));
    //Calculate bottom right of inventory.
    var inventory_x2 = inventory_x1 + inventory_width;
    var inventory_y2 = inventory_y1 + inventory_height;
    
    var x1 = inventory_x1;
    var y1 = inventory_y1;
    var x2 = inventory_x2;
    var y2 = inventory_y2;
    
    //Draw the inventory background.
    draw_set_alpha(bg_alpha);
    draw_set_color(bg_color);
    draw_rectangle(x1,y1,x2,y2,false);
    
    //Set x1,y1,x2,y2 to the first cell.
    x1 += x_padding;
    y1 += y_padding
    x2 = x1 + cell_size;
    y2 = y1 + cell_size;
    
    //Save the starting x values so we can
    //remember where the first columns are drawn.
    var original_x1 = x1;
    var original_x2 = x2;
    
    //Draw inventory cells.
    for(var i = 0; i &lt; rows; i++)
    {
        for(var j = 0; j &lt; cols; j++)
        {
            //Set inventory cell color.
            draw_set_alpha(cell_alpha);
            draw_set_color(cell_color);
            
            //Draw cell.
            draw_rectangle(x1,y1,x2,y2,false);
            
            //Current slot.
            var slot = i * cols + j;
            //Current item.
            var item = inventory[slot];
            
            //Save top left x,y of current slot for
            //collision detection later.
            inventory_cell_x[slot] = x1;
            inventory_cell_y[slot] = y1;
                        
            //Draw sprite at cell
            //if the current slot has an item,
            if(item != empty)
            {
                //If that item has a sprite,
                if(item.sprite_index != -1)
                {
                    //If we're not dragging this item,
                    if(slot != dragging_item_index)
                    {
                        scr_inventory_draw_sprite(item,x1,y1);
                    }
                }
            }
            
            //Move to next cell in the current row.    
            x1 += cell_size + x_padding;
            x2 += cell_size + x_padding;
        }
        //Go to next row.
        y1 += cell_size + y_padding;
        y2 += cell_size + y_padding;
        //Move back to first column.
        x1 = original_x1;
        x2 = original_x2;
    }
    
    //Set alpha back to normal so everything else draws properly.
    draw_set_alpha(1.0);

    if(mouse_check_button_pressed(mb_left) || mouse_check_button_pressed(mb_right))
    {
        //If we clicked inside the inventory,
        if(point_in_rectangle(mouse_x,mouse_y,inventory_x1,inventory_y1,inventory_x2,inventory_y2))
        {
            show_debug_message("clicked in inventory.");
            //We check every slot if it was clicked,
            for(var i = 0; i &lt; inventory_capacity; i++)
            {
                var x1 = inventory_cell_x[i];
                var y1 = inventory_cell_y[i];
                var x2 = x1 + cell_size;
                var y2 = y1 + cell_size;
                //If we click on slot i,
                if(point_in_rectangle(mouse_x,mouse_y,x1,y1,x2,y2))
                {
                    if(mouse_check_button_pressed(mb_left))
                    {//If we left clicked.
                        show_debug_message("left clicked on inventory slot " + string(i));
                        //If we're already dragging something,
                        if(dragging_item_index &gt; -1)
                        {
                            //If the slot is not empty,
                            if(inventory[i] != empty)
                            {
                                //If the item in the slot is stackable, it's the same object
                                //we're dragging, but
                                if(inventory[i].stackable &amp;&amp;
                                inventory[i].object_index == inventory[dragging_item_index].object_index &amp;&amp;
                                i != dragging_item_index
                                )
                                {
                                    //We merge the items together.
                                    
                                    //Save the stack_size of the item we will destroy.
                                    var merge_stack_size = inventory[dragging_item_index].stack_size;
                                    
                                    //Destroy the instance
                                    with(inventory[dragging_item_index])
                                    {
                                        instance_destroy();
                                    }
                                    
                                    //Update the stack value of the item in the slot.
                                    inventory[i].stack_size += merge_stack_size;
                                    
                                    //We need to set that slot to empty.
                                    inventory[dragging_item_index] = empty;
                                    //We're not dragging anything now.
                                    dragging_item_index = -1;
                                    
                                    
                                }
                                else
                                {//Otherwise we swap,
                                    //Swap the two slots.
                                    var temp_item = inventory[i];
                                    inventory[i] = inventory[dragging_item_index];
                                    inventory[dragging_item_index] = temp_item;
                                    
                                    //If this is the same slot as the item we're dragging,
                                    //then we 'place it back' and stop dragging.
                                    if(dragging_item_index == i)
                                    {
                                        dragging_item_index = -1;
                                    }
                                    //otherwise, we're now dragging the item we clicked on.
                                    break;
                                }
                            }
                            else
                            {//If it's an empty slot, we drop the item into this slot.
                                inventory[i] = inventory[dragging_item_index];
                                inventory[dragging_item_index] = empty;
                                
                                //Don't drag anything now.
                                dragging_item_index = -1;
                            }
                        }
                        else
                        {//If we're not dragging anything,
                            //If it's not an empty slot,
                            if(inventory[i] != empty)
                            {
                                //dragging_item_index = i;
                                
                                //Start dragging this item.
                                
                                //Put it into the extra slot.
                                inventory[inventory_capacity] = inventory[i];
                                
                                //Set its old slot to empty.
                                inventory[i] = empty;
                                
                                dragging_item_index = inventory_capacity;
                                //break;
                            }
                        }
                    }
                    else //If we right clicked.
                    {
                        show_debug_message("right clicked on inventory slot " + string(i));
                        
                        //If we right clicked on an item,
                        if(inventory[i] != empty)
                        {
                            //If it's stackable,
                            if(inventory[i].stackable)
                            {   
                                //If we're not dragging anything already,
                                if(dragging_item_index &lt; 0)
                                {
                                    if(inventory[i].stack_size == 1)
                                    {
                                        //Pick up the stack and put it in the extra slot.
                                        
                                        //inventory[inventory_capacity] = inventory[i];
                                        //inventory[i] = empty;
                                        //dragging_item_index = inventory_capacity;
                                    }
                                    else
                                    {//Stack size &gt; 1.
                                        //Reduce the stack_size of the item we're taking
                                        //out from.
                                        inventory[i].stack_size--;
                                        
                                        //Create a new instance of this item.
                                        var new_stack_item = instance_create(0,0,inventory[i].object_index);
                                        new_stack_item.on_ground = false;
                                        new_stack_item.visible = false;
                                        //This line isn't necessary because by default items
                                        //start with a stack_size of 1.
                                        //new_stack.stack_size = 1;
                                        
                                        //Add this new item to the extra inventory slot.
                                        inventory[inventory_capacity] = new_stack_item;
                                        
                                        //Start dragging it(in the extra slot),
                                        dragging_item_index = inventory_capacity;
                                    }
                                }
                                else
                                {//If we're already dragging something,
                                    //If the item we're dragging is stackable,
                                    if(inventory[dragging_item_index].stackable)
                                    {
                                        //If the item we're dragging is the same
                                        //item as the one we clicked on,
                                        if(inventory[i].object_index == inventory[dragging_item_index].object_index)
                                        {
                                            //Reduce its stack_size.
                                            inventory[i].stack_size--;
                                            //Increase the dragging item's stack_size.
                                            inventory[dragging_item_index].stack_size++;
                                            
                                            //If we picked up the entire stack,
                                            if(inventory[i].stack_size &lt; 1)
                                            {
                                                with(inventory[i])
                                                {
                                                    instance_destroy();
                                                }
                                                inventory[i] = empty;
                                            }
                                        }
                                        
                                    }
                                }
                            }
                        }
                        /*else
                        {//If it's an empty slot.
                            //If we're dragging an item,
                            if(dragging_item_index &gt; -1)
                            {
                                //If it's stackable,
                                if(inventory[dragging_item_index].stackable)
                                {
                                    //If there is only one item in the stack we are dragging,
                                    if(inventory[dragging_item_index].stack_size == 1)
                                    {
                                        //Just drop it into this slot.
                                        inventory[i] = inventory[dragging_item_index];
                                        inventory[dragging_item_index] = empty;
                                        dragging_item_index = -1;
                                    }
                                    else
                                    {//Otherwise, we drop one of it into the slot.
                                        //Make a new item.
                                        var new_stack_item = instance_create(0,0,inventory[dragging_item_index].object_index);
                                        new_stack_item.on_ground = false;
                                        new_stack_item.visible = false;
                                        
                                        //Put it into this slot.
                                        inventory[i] = new_stack_item;
                                        
                                        //The new item's stack size is automatically 1 because 
                                        //of obj_item's create event.
                                        
                                        //Reduce the dragging_item's stack.
                                        inventory[dragging_item_index].stack_size--;
                                        
                                        //d/fd/f
                                        //Add this new item to the extra inventory slot.
                                        //inventory[inventory_capacity] = new_stack_item;
                                        
                                        //Start dragging it(in the extra slot),
                                        //dragging_item_index = inventory_capacity;
                                    }                                    
                                }
                            }
                               
                        }*/
                    }
                }
            }
        }
        else
        {//If we clicked outside the inventory,
            //If we're dragging an item,
            if(dragging_item_index &gt; -1)
            {
                //This should never happen but it's good to check.
                if(inventory[dragging_item_index] == empty)
                {
                    show_debug_message("dragging empty");
                }
                
                var item = inventory[dragging_item_index];
                //Drop the item.
                item.on_ground = true;
                item.visible = true;
                //We are using 16 because sprite_width/2 = 16 for sprites 32x32.
                //If we use a different sprite size we need to change the following.
                item.x = mouse_x-16
                item.y = mouse_y-16
                //Remove the item from the inventory.
                inventory[dragging_item_index] = empty;
                //We're no longer dragging it.
                dragging_item_index = -1;
            }
        }
    }
    
    //If we're dragging an item,
    if(dragging_item_index &gt; -1)
    {
        scr_inventory_draw_sprite(inventory[dragging_item_index],mouse_x-(cell_size/2),mouse_y-(cell_size/2));
    }
}
//else
//{//We're dragging this item, so draw it at the mouse.
//    scr_inventory_draw_sprite(item, mouse_x, mouse_y);                     
//}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
///Draw Loadout bar

//This code assumes we will always use view[0].
view_width = view_wview[0];
view_height = view_hview[0];

//Cell variables:
var cell_size = 48;

//The padding between cells.
var x_padding = 8;
var y_padding = 8;

var cell_alpha = 0.95;
var cell_color = c_gray;

//Border variables:
var border_height = cell_size+(2*y_padding);
var border_width = view_width;

var border_alpha = 0.55;
var border_color = c_black;

//Top left coordinates of border:
var x1 = view_xview[0];
var y1 = view_yview[0] + (view_height - border_height);
//Bottom right coordinates of border:
var x2 = view_xview[0] + view_width;
var y2 = view_yview[0] + view_height;

//Draw border.
draw_set_alpha(border_alpha);
draw_set_color(border_color);
draw_rectangle(x1,y1,x2,y2,false);

//Draw cells

//Update starting position of cells.
x1 += x_padding/2;
y1 += y_padding;
x2 = x1 + cell_size;
y2 = y1 + cell_size;

draw_set_alpha(cell_alpha);
draw_set_color(cell_color);

//Draw all cells.
for(var i = 0; i &lt; 12; i++)
{

    draw_rectangle(x1,y1,x2,y2,false);
    
    x1 += cell_size + x_padding;
    x2 += cell_size + x_padding;
}

//Set alpha back to normal so everything else draws properly.
draw_set_alpha(1.0);

//Draw Inventory

var rows = 4;
var cols = 8;

x_padding = 8;
y_padding = x_padding;

var inventory_width = (cols * cell_size) + ((cols+1) * x_padding);
var inventory_height = (rows * cell_size) + ((rows+1) * y_padding);

//Calculate center of screen if we exclude the Loadout bar.
var available_area_height = (view_height - border_height);
var available_area_width = view_width;
var center_x = available_area_width/2;
var center_y = available_area_height/2;

//Calculate top left of the Inventory.
x1 = view_xview[0] + (center_x - (inventory_width/2));
y1 = view_yview[0] + (center_y - (inventory_height/2));
//Calculate bottom right of inventory.
x2 = x1 + inventory_width;
y2 = y1 + inventory_height;

draw_set_alpha(border_alpha);
draw_set_color(border_color);
draw_rectangle(x1,y1,x2,y2,false);

//Update starting position of cells.
x1 += x_padding;
y1 += y_padding
x2 = x1 + cell_size;
y2 = y1 + cell_size;

var original_x1 = x1;
var original_x2 = x2;

draw_set_alpha(cell_alpha);
draw_set_color(cell_color);
for(var i = 0; i &lt; rows; i++)
{
    for(var j = 0; j &lt; cols; j++)
    {
        draw_rectangle(x1,y1,x2,y2,false);
    
        x1 += cell_size + x_padding;
        x2 += cell_size + x_padding;
    }
    y1 += cell_size + y_padding;
    y2 += cell_size + y_padding;
    x1 = original_x1;
    x2 = original_x2;
}
//*/




//How big do we want our inventory to be?
/*
if(canDraw){
    var cellWidth = 48;
    var cellHeight = 48;
    
    draw_set_color(c_gray);
    draw_set_alpha(0.8);
    draw_set_font(font_inventory);
    
    var startX = view_xview[0] + 256;
    var startY = view_yview[0] + 144;
    
    var width = 576;
    var height = 288;


    draw_rectangle(startX, startY, startX + width, startY + height, false);
    
    
    var xx = startX + 32;
    var yy = startY + 32;
    draw_set_color(c_green);
    draw_set_alpha(0.95);
    draw_rectangle(xx, yy, xx + cellWidth, yy + cellHeight, false);
    coordX[15] = xx;
    coordY[15] = yy;
    
    
    for(xx = startX + 32; xx &lt; startX + width; xx+=110){
        for(yy = startY + 96; yy &lt; startY + height; yy += 64){
            coordX[curSlot] = xx;
            coordY[curSlot] = yy;
            
            draw_set_color(c_dkgray);
            draw_set_alpha(0.95);
            draw_rectangle(xx, yy, xx + cellWidth, yy + cellHeight, false);
            curSlot++;
            if(curSlot &gt;= totalSlots-2){
                curSlot = 0;    
            }
        }
        scr_manageObjects(cellWidth, cellHeight);
    }
    
    draw_set_alpha(1);
    draw_set_color(c_white);
}
//*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="49">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drink potion

/*
if(canUse == true)
{
    alarm[0] = cooldown;
    
    if(global.item[1] &gt; 0 &amp;&amp; global.slot[15] == "potion")
    {
        obj_char.hp+=5;
        global.item[1]--;   
    }

    canUse = false;   
}
//*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
