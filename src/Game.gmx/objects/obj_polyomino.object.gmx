<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_terrain_makeinvulnerable</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Try to generate a large polyomino that fits in a room.

/*var polyomino = generate_polyomino_roomfit(irandom_range(1000,2500));
if(is_undefined(polyomino))
{
    show_debug_message("undefined");
    exit;
}*/
var polyomino;
do
{
    
    polyomino = generate_polyomino_roomfit(irandom_range(2500,3000));
} until(not(is_undefined(polyomino)));
print_grid(polyomino);
var rows = ds_grid_height(polyomino);
var cols = ds_grid_width(polyomino);
var xx = 0;
var yy = 0;
for(var r = 0; r &lt; rows; r++)
{
    for(var c = 0; c &lt; cols; c++)
    {
        var value = ds_grid_get(polyomino,c,r);
        show_debug_message("x " + string(xx) + " y " + string(yy));
        switch(value)
        {
            case 1:
                instance_create(xx,yy,obj_terrain_floor);
                break;
            case 2:
                instance_create(xx,yy,obj_terrain_wall);
                break;
        }
        xx += 32;
    }
    yy += 32;
    xx = 0;
}

ds_grid_destroy(polyomino);
exit;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Unused old code
/*
//var cells = 5000;//4677;
//var rows = cells + cells + 1;
//var cols = rows;
var cells = 4000;
//var rows = floor(room_height/32);
//var cols = floor(room_width/32);
var rows = 1000;
var cols = 1000;
var grid;
grid = ds_grid_create(cols,rows);//ds_grid_create(cols,rows);
show_debug_message("width: " + string(rows) + " height: " + string(cols));

show_debug_message("done first init");
var possible;
var length = (cells * 3) + 1;

var found = false;
var count = 0;
while(not found)
{

    possible[length-1,0] = 0;
    possible[length-1,1] = 0;
    
    for(var i = 0; i &lt; length; i++)
    {
        for(var j = 0; j &lt; 2; j++)
        {
            possible[i,j] = 0;
        }
    }
    
    var last_position = 0;
    var ROW = 0;
    var COL = 1;
    //var center_of_grid = cells;
    //possible[last_position,ROW] = center_of_grid;
    //possible[last_position,COL] = center_of_grid;
    possible[last_position,ROW] = floor(rows/2);
    possible[last_position,COL] = floor(cols/2);
    show_debug_message("center (col,row) = (" + string(floor(cols/2)) + "," + string(floor(rows/2)) + ")");
    var pick = last_position;
    show_debug_message("done initializing");

    count++;
    ds_grid_clear(grid,0);
    show_debug_message("iteration " + string(count));
    for(var i = 0; i &lt; cells; i++)
    {
        var pick_row = possible[pick,ROW];
        var pick_col = possible[pick,COL];
        
        //if(pick_row &lt; 0 or pick_row &gt;= rows or pick_col &lt; 0 or pick_col &gt;= cols)
        if(pick_row &gt;= (rows-1) or pick_col &gt;= (cols-1))
        {
            show_debug_message("Breaking!");
            break;
        }
    
        var last_row = possible[last_position,ROW];    
        var last_col = possible[last_position,COL];
    
        possible[pick,ROW] = last_row;
        possible[pick,COL] = last_col;
        last_position--;
        
        ds_grid_set(grid, pick_col, pick_row, 1);
        //grid[pick_row, pick_col] = 1;
        
        var r = pick_row;
        var c = pick_col;
        
        show_debug_message("pickrow " + string(r) + " pickcol " + string(c));
        
        var left_row = pick_row;
        var left_col = pick_col - 1;
        var right_row = pick_row;
        var right_col = pick_col + 1;;
        var up_row = pick_row - 1;
        var up_col = pick_col;
        var down_row = pick_row + 1;
        var down_col = pick_col;
        //show_debug_message("lrow " + string(left_row) + " lcol " + string(left_col));
        
        //if(grid[left_row, left_col] == 0)
        if(ds_grid_get(grid, left_col, left_row) == 0)
        {
            //grid[left_row, left_col] = 2;
            ds_grid_set(grid, left_col, left_row, 2);
            last_position++;
            possible[last_position,ROW] = left_row;
            possible[last_position,COL] = left_col;
        }
        
        //if(grid[right_row, right_col] == 0)
        if(ds_grid_get(grid, right_col, right_row) == 0)
        {
            //grid[right_row, right_col] = 2;
            ds_grid_set(grid, right_col, right_row, 2);
            last_position++;
            possible[last_position,ROW] = right_row;
            possible[last_position,COL] = right_col;
        }
        
        //if(grid[up_row, up_col] == 0)
        if(ds_grid_get(grid, up_col, up_row) == 0)
        {
            //grid[up_row, up_col] = 2;
            ds_grid_set(grid, up_col, up_row, 2);
            last_position++;
            possible[last_position,ROW] = up_row;
            possible[last_position,COL] = up_col;
        }
        
        //if(grid[down_row, down_col] == 0)
        if(ds_grid_get(grid, down_col, down_row) == 0)
        {
            //grid[down_row, down_col] = 2;
            ds_grid_set(grid, down_col, down_row, 2);
            last_position++;
            possible[last_position,ROW] = down_row;
            possible[last_position,COL] = down_col;
        }
        
        pick = irandom(last_position);
        
        if(i == cells-1)
        {
            found = true;
        }
        
    }
}
//*/
for(var r = 0; r &lt; rows; r++)
{
    var message = "";
    for(var c = 0; c &lt; cols; c++)
    {
        message += string(ds_grid_get(grid,c,r)) + " ";
    }
    show_debug_message(message);
}
ds_grid_destroy(grid);
//*/
/*
var min_row = possible[0,ROW];
var min_col = possible[0,COL];
var max_row = min_row;
var max_col = min_col;

for(var i = 0; i &lt;= last_position; i++)
{
    if(possible[i,ROW] &lt; min_row)
    {
        min_row = possible[i,ROW];
    }
    if(possible[i,ROW] &gt; max_row)
    {
        max_row = possible[i,ROW];
    }
    if(possible[i,COL] &lt; min_col)
    {
        min_col = possible[i,COL];
    }
    if(possible[i,COL] &gt; max_col)
    {
        max_col = possible[i,COL];
    }
}

possible = 0;

show_debug_message("min: (" + string(min_col) + "," + string(min_row) + ")");
show_debug_message("max: (" + string(max_col) + "," + string(max_row) + ")");


var final_grid_rows = max_row - min_row + 1;
var final_grid_cols = max_col - min_col + 1;

show_debug_message("width " + string(final_grid_cols) + " height " + string(final_grid_rows));

final_grid = ds_grid_create(final_grid_cols,final_grid_rows);
ds_grid_set_grid_region(final_grid,grid,min_col,min_row,max_col,max_row,0,0);

ds_grid_destroy(grid);


for(var r = 0; r &lt; final_grid_rows; r++)
{
    var message = "";
    for(var c = 0; c &lt; final_grid_cols; c++)
    {
        message += string(ds_grid_get(final_grid,c,r)) + " ";
    }
    show_debug_message(message);
}
ds_grid_destroy(final_grid);
//*/
//print_2d_array(grid,rows,cols);
/*var show_cols = "  ";
for(var i = 0; i &lt; cols; i++)
{
    show_cols += string(i) + " ";
}
show_debug_message(show_cols);
for(var r = 0; r &lt; rows; r++)
{
    var message = string(r) + " ";
    for(var c = 0; c &lt; cols; c++)
    {
        message += string(grid[r,c]) + " ";
    }
    show_debug_message(message);
}
var message = "";
for(var i = 0; i &lt;= last_position; i++)
{
    message += "(" + string(possible[i,COL]) + "," + string(possible[i,ROW]) + ") ";
}
show_debug_message(message);

var min_row = possible[0,ROW];
var min_col = possible[0,COL];
var max_row = min_row;
var max_col = min_col;

for(var i = 0; i &lt;= last_position; i++)
{
    if(possible[i,ROW] &lt; min_row)
    {
        min_row = possible[i,ROW];
    }
    if(possible[i,ROW] &gt; max_row)
    {
        max_row = possible[i,ROW];
    }
    if(possible[i,COL] &lt; min_col)
    {
        min_col = possible[i,COL];
    }
    if(possible[i,COL] &gt; max_col)
    {
        max_col = possible[i,COL];
    }
}

show_debug_message("min: (" + string(min_col) + "," + string(min_row) + ")");

show_debug_message("max: (" + string(max_col) + "," + string(max_row) + ")");

var final_grid_rows = max_row - min_row + 1;
var final_grid_cols = max_col - min_col + 1;
final_grid[final_grid_rows-1,final_grid_cols-1] = 0;
var i = 0;
var j = 0;
for(var r = min_row; r &lt;= max_row; r++)
{
    j = 0;
    for(var c = min_col; c &lt;= max_col; c++)
    {
        //show_debug_message("i " + string(i) + " j " + string(j) + "value " + string(grid[r,c]));
        final_grid[i,j] = grid[r,c];
        j++;
    }
    i++;
}


show_debug_message("final_grid_rows " + string(final_grid_rows) + " final_grid_cols " + string(final_grid_cols));
for(var r = 0; r &lt; final_grid_rows; r++)
{
    var display_trimmed = "";
    for(var c = 0; c &lt; final_grid_cols; c++)
    {
        display_trimmed += string(final_grid[r,c]) + " ";
    }
    show_debug_message(display_trimmed);
}

*/
show_debug_message("done generating");

















</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Buffer method is too slow.
var cells = 1000;
var rows = cells + cells + 1;
var cols = rows;
//var buffer = buffer_create(rows*cols,buffer_fast,1);
var buffer = buffer_create(rows*cols*4,buffer_fixed,4);

/*for(var r = 0; r &lt; rows; r++)
{
    for(var c = 0; c &lt; cols; c++)
    {
        buffer_poke(buffer,r*cols+c,buffer_u8,1);
    }
}*/
for(var i = 0; i &lt; rows*cols; i++)
{
    //buffer_poke(buffer,i,buffer_u8,1);
    buffer_poke(buffer,i,buffer_u32,1);
}
show_debug_message("done writing");


/*for(var r = 0; r &lt; rows; r++)
{
    var message = "";
    for(var c = 0; c &lt; cols; c++)
    {
        buffer_peek(buffer,r*cols+c,buffer_u8);
        //message += string(buffer_peek(buffer,r*cols+c,buffer_u8)) + " ";
    }
    //show_debug_message(message);
}*/
for(var i = 0; i &lt; rows*cols; i++)
{
    //buffer_peek(buffer,i,buffer_u8);
    buffer_peek(buffer,i,buffer_u32);
}
show_debug_message("done showing");
//buffer_poke(buffer,0,buffer_u8,1);

//show_debug_message(string(buffer_peek(buffer,0,buffer_u8)));
buffer_delete(buffer);
exit;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
